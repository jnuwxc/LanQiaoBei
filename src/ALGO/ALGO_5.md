# ALGO_5 算法训练 最短路 

## 问题描述

给定一个n个顶点，m条边的有向图（其中某些边权可能为负，但保证没有负环）。请你计算从1号点到其他点的最短路（顶点从1到n编号）。

## 输入格式

第一行两个整数n, m。

接下来的m行，每行有三个整数u, v, l，表示u到v有一条长度为l的边。

## 输出格式

共n-1行，第i行表示1号点到i+1号点的最短路。

## 样例输入

```
3 3
1 2 -1
2 3 -1
3 1 2
```

## 样例输出

```
-1
-2
```

## 数据规模与约定

对于10%的数据，n = 2，m = 2。

对于30%的数据，n <= 5，m <= 10。

对于100%的数据，1 <= n <= 20000，1 <= m <= 200000，-10000 <= l <= 10000，保证从任意顶点都能到达其他所有顶点。

## 题解

图的最短路径问题，常见的算法有迪杰斯特拉、弗洛依达、Bellman-Ford算法等。

本题中因为存在负边权（但不存在负的环），所以不能使用迪杰斯特拉，只能使用Bellman-Ford算法。

下面是对该算法的解释

>贝尔曼-福特算法与迪科斯彻算法类似，都以松弛操作为基础，即估计的最短路径值渐渐地被更加准确的值替代，直至得到最优解。
在两个算法中，计算时每个边之间的估计距离值都比真实值大，并且被新找到路径的最小长度替代。 
然而，迪科斯彻算法以贪心法选取未被处理的具有最小权值的节点，然后对其的出边进行松弛操作；
而贝尔曼-福特算法简单地对所有边进行松弛操作，共 |V|-1次，其中 |V|是图的点的数量。
在重复地计算中，已计算得到正确的距离的边的数量不断增加，直到所有边都计算得到了正确的路径。
这样的策略使得贝尔曼-福特算法比迪科斯彻算法适用于更多种类的输入。
贝尔曼-福特算法的最多运行 （大O符号）次，|V|和 |E|分别是节点和边的数量）

针对该算法有很多种优化，其中最常见的是SPFA算法（提出者段凡丁，这一算法虽然后来被证明并非是完全正确的，有时复杂度仍会等同于未优化时）

SPFA主要思想是使用队列来优化，他认为松弛操作只会发生在最短路径前导结点成功松弛过的结点上，所以用队列存储这次松弛过的结点，
在下一次松弛时就可以直接按队列中的结点来操作，避免冗余计算。但该结论被证明不适用于所有情况，，，这题是可以的。